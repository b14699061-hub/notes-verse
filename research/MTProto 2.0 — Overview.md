

> _Based on “Mobile Protocol: Detailed Description” from Telegram’s core docs._ 

## 1. What it is

- A protocol for client-server encryption (cloud chats) used by Telegram’s clients. 
- Version 2.0 is the current standard; version 1.0 is deprecated.
- Key changes in v2.0 vs v1.0:
    - Use of SHA-256 instead of SHA-1. 
    - Padding bytes are included in msg_key computation. 
    - msg_key depends on part of auth_key as well. 
    - Padding length changed: 12..1024 bytes instead of 0..15. 


## 2. Terminology

### Authorization Key (`auth_key`)

- A 2048-bit key shared between client and server, generated via a Diffie-Hellman exchange on the client side. 
    
- Never transmitted directly over the network once established. 
    

### Key Identifier (`auth_key_id`)

- The 64 lower-order bits of the SHA-1 hash of the auth_key. 
    
- Indicates which key was used to encrypt a message.
    
- In special registration messages a value of zero means “no encryption”. 
    

### Session

- A random 64-bit number generated by the client to distinguish between different application instances (even if they use the same auth_key). 
    

### Server Salt

- A random 64-bit number changed by the server every ~30 minutes (per session). 
    
- Helps protect against replay attacks and clock-adjustment tricks. 
    

### Message Identifier (`msg_id`)

- 64-bit number, time-dependent, used to uniquely identify a message in a session. 
    
- Client message IDs are divisible by 4; server ones have specific parity rules. 
    
- Must increase monotonically for a given session. 
    

### Message Sequence Number (`msg_seqno`)

- 32-bit number that reflects ordering of content-related vs non-content messages. 
    
- If content-related, `msg_seqno = (current_seqno * 2) + 1`, and `current_seqno` is incremented. Non-content: `msg_seqno = (current_seqno * 2)`. 
    
- Helps the receiver determine whether a message requires acknowledgement. 
    

## 3. Message Format

### Plain (unencrypted) message

Used only during initial key creation / time sync.

```
auth_key_id = 0 (64 bits)  
int64 message_id  
int32 message_data_length  
bytes message_data  
```



### Encrypted message

```
auth_key_id (64 bits)  
msg_key (128 bits)  
encrypted_data (bytes)  
```

Within encrypted_data after decryption you’ll find:

```
salt (64 bits)  
session_id (64 bits)  
message_id (64 bits)  
seq_no (32 bits)  
message_data_length (32 bits)  
message_data (bytes)  
padding (12..1024 bytes)  
```



### Visual summary

![Image](https://core.telegram.org/file/811140746/2/CzMyJPVnPo8.81605/c2310d6ede1a5e220f)

![Image](https://www.researchgate.net/publication/346702021/figure/fig1/AS%3A966314487189511%401607398735861/The-MTProto-20-suite-light-blue-box-The-subject-of-the-present-work-is-the.png)

![Image](https://ars.els-cdn.com/content/image/1-s2.0-S0167404822004643-gr2.jpg)


## 4. Cryptography & Key Derivation

### msg_key

- In v2.0: the _middle_ 128 bits of `SHA-256(auth_key_fragment + plaintext + padding)` where a 32-byte fragment of auth_key is prepended. 
    
- In v1.0: lower 128 bits of SHA-1 of the plaintext (without padding) — deprecated. 
    

### Deriving `aes_key` and `aes_iv`

Given `auth_key` and `msg_key`, compute:

```c
msg_key_large = SHA256(substr(auth_key, 88 + x, 32) + plaintext + padding)
msg_key       = substr(msg_key_large, 8, 16)

sha256_a = SHA256(msg_key + substr(auth_key, x, 36))
sha256_b = SHA256(substr(auth_key, 40 + x, 36) + msg_key)

aes_key = substr(sha256_a, 0, 8) +
          substr(sha256_b, 8, 16) +
          substr(sha256_a, 24, 8)

aes_iv  = substr(sha256_b, 0, 8) +
          substr(sha256_a, 8, 16) +
          substr(sha256_b, 24, 8)
```

Where _x = 0_ for client→server messages, _x = 8_ for server→client. 

- Encryption used: AES-256 in Infinite Garble Extension (IGE) mode. 
    

## 5. Security Checks & Replay Protection

- On decryption: verify that `msg_key` matches the expected value (the middle 128 bits of SHA-256 of decrypted data with auth_key fragment). 
    
- Check `msg_id`: must be greater than previously received ones, and not more than ~300 seconds in the past or ~30 seconds in the future. 
    
- Lower bits of `msg_id` must not be empty — ensures fractional part of timestamp. 
    

## 6. Session & Salt Management

- Each session uses a server salt that the server updates (~every 30 minutes). Once updated, all further messages must include the new salt; old salt accepted for ~1800 s. 
    
- The client can create new sessions (by choosing new random session_id) at any time. 
    

## 7. Why this design?

- Padding length being large (12-1024 bytes) increases unpredictability of message size — helps thwart traffic analysis.
    
- Including part of auth_key in msg_key derivation ties the encryption to the specific key; makes manipulation harder.
    
- Using SHA-256 improves hash strength over SHA-1.
    
- The session/salt/sequence system provides protection against replay & session hijacking.
    
- The external header (auth_key_id + msg_key) and internal header (salt + session_id) cleanly separate key-identification and secure content.
    

## 8. Quick Visual Flow

1. Client & server create auth_key via Diffie-Hellman.
    
2. Client starts a session: picks session_id, gets initial server_salt.
    
3. To send a message:
    
    - Build plaintext: salt, session_id, msg_id, seq_no, length, data, padding.
        
    - Compute msg_key (with auth_key fragment + plaintext + padding).
        
    - Derive aes_key / aes_iv from auth_key + msg_key.
        
    - Encrypt plaintext with AES-256-IGE to get encrypted_data.
        
    - Send: auth_key_id || msg_key || encrypted_data.
        
4. Receiver decrypts, checks msg_key and other fields, ensures freshness & ordering.
    
5. Server may update salt; client must respect new salt in subsequent messages.
    

![Image](https://www.researchgate.net/publication/346702021/figure/fig1/AS%3A966314487189511%401607398735861/The-MTProto-20-suite-light-blue-box-The-subject-of-the-present-work-is-the.png)

![Image](https://www.researchgate.net/publication/346702021/figure/fig2/AS%3A966314487197698%401607398735895/MTProto-20s-Authentication-Protocol-In-this-and-the-next-diagrams-m-pk-represents.png)

![Image](https://core.telegram.org/file/811140633/4/hHw6Zy2DPyQ.109500/cabc10049a7190694f)

![Image](https://ars.els-cdn.com/content/image/1-s2.0-S0167404822004643-gr2.jpg)

![Image](https://core.telegram.org/file/811140746/2/CzMyJPVnPo8.81605/c2310d6ede1a5e220f)

## 9. Things to Explore Further

- The registration flow / Diffie-Hellman key exchange for creating the auth_key.
    
- How multi-part (“container”) messages are handled.
    
- Differences for “secret chats” (end-to-end encryption) beyond this base layer.
    
- Implementation details of AES-IGE and padding handling.
    
- How TLS/transport layer interacts (TCP vs HTTP vs other transports) though this protocol layer is transport-agnostic to some degree.
    

---

You can use this note as a starting point in Obsidian, and hyperlink to deeper dives for each bullet when you want more detail. If you like, I can **produce a fully-formatted Obsidian markdown file** (with diagrams embedded) for you. Would you like that?